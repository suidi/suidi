<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta name="description" content="世界更新的速度比你努力的速度要快，努力的目的是不至于被世界落下太远。">
<meta property="og:type" content="website">
<meta property="og:title" content="BUG吧">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="BUG吧">
<meta property="og:description" content="世界更新的速度比你努力的速度要快，努力的目的是不至于被世界落下太远。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="BUG吧">
<meta name="twitter:description" content="世界更新的速度比你努力的速度要快，努力的目的是不至于被世界落下太远。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>BUG吧</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">BUG吧</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/21/Swift-ABI-稳定对我们到底意味着什么/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小怪兽">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/girl.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BUG吧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/21/Swift-ABI-稳定对我们到底意味着什么/" itemprop="url">Swift ABI 稳定对我们到底意味着什么</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-21T14:49:19+07:00">
                2019-05-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Swift 社区最近最重大的新闻应该就是 ABI 稳定了。这个话题虽然已经讨论了有一阵子了，但随着 Xcode 10.2 beta 的迭代和 Swift 5 的 release 被提上日程，最终 Swift ABI 稳定能做到什么程度，我们开发者能做些什么，需要做些什么，就变成了一个重要的话题。Apple 在这个月接连发布了 ABI Stability and More 和 Evolving Swift On Apple Platforms After ABI Stability 两篇文章来阐述 Swift 5 发布以后 ABI 相关的内容所带来的改变。虽然原文不是很长，但是有些地方上下文没有说太清楚，可能不太容易理解。本文希望对这个话题以问答的形式进行一些总结，让大家能更明白将要发生的事情。</p>
<h4 id="我是一个-app-开发者，Swift-5-发布以后会怎么样？"><a href="#我是一个-app-开发者，Swift-5-发布以后会怎么样？" class="headerlink" title="我是一个 app 开发者，Swift 5 发布以后会怎么样？"></a>我是一个 app 开发者，Swift 5 发布以后会怎么样？</h4><p>简单说，安装 Xcode 10.2，然后正常迁移就可以了，和以往 Swift 3 到 Swift 4 需要做的事情差不多。单论 Swift 5 这个版本，不会对你的开发造成什么影响，直到下一个版本 (比如 Swift 5.1) 之前，你几乎不需要关心 ABI 稳定这件事。关于下个 Swift 版本，我们稍后会提到这件事情。</p>
<p>我还是想知道什么是 ABI 稳定？<br>就是 binary 接口稳定，也就是在运行的时候只要是用 Swift 5 (或以上) 的编译器编译出来的 binary，就可以跑在任意的 Swift 5 (或以上) 的 runtime 上。这样，我们就不需要像以往那样在 app 里放一个 Swift runtime 了，Apple 会把它弄到 iOS 和 macOS 系统里。</p>
<h4 id="所以说-app-尺寸会变小？"><a href="#所以说-app-尺寸会变小？" class="headerlink" title="所以说 app 尺寸会变小？"></a>所以说 app 尺寸会变小？</h4><p>是的，但是这是 Apple 通过 App Thinning 帮我们完成的，不需要你操心。在提交 app 时，Apple 将会按照 iOS 系统创建不同的下载包。对于 iOS 12.2 的系统，因为它们预装了 Swift 5 的 runtime，所以不再需要 Swift 的库，它们会被从 app bundle 中删掉。对于 iOS 12.2 以下的系统，外甥打灯笼，照旧。</p>
<p>一个新创建的空 app，针对 iOS 12.2 打包出来压缩后的下载大小是 26KB，而对 iOS 12.0 则是 2.4MB。如果你使用了很多标准库里的东西，那这个差距会更大 (因为没有用到的标准库的符号会被 strip 掉)，对于一个比较有规模的 app 来说，一般可以减小 10M 左右的体积。</p>
<h4 id="还有什么其他好处么？"><a href="#还有什么其他好处么？" class="headerlink" title="还有什么其他好处么？"></a>还有什么其他好处么？</h4><p>因为系统集成了 Swift，所以大家都用同一个 Swift 了，app 启动的时候也就不需要额外加载 Swift，所以在新系统上会更快更省内存。当然啦，只是针对新系统。</p>
<p>另外，对于 Apple 的工程师来说，他们终于能在系统的框架里使用 Swift 了。这样一来，很多东西就不必通过 Objective-C wrap 一遍，这会让代码运行效率提高很多。虽然在 iOS 12.2 中应该还没有 Swift 编写的框架，但是我们也许能在不久的将来看到 Swift 被 Apple 自己所使用。等今年 WWDC 的消息吧。</p>
<h4 id="我还想用一段时间的-Xcode-10-1，不太想这么快升级"><a href="#我还想用一段时间的-Xcode-10-1，不太想这么快升级" class="headerlink" title="我还想用一段时间的 Xcode 10.1，不太想这么快升级"></a>我还想用一段时间的 Xcode 10.1，不太想这么快升级</h4><p>Xcode 10.1 里的是 Swift 4.2 的编译器，出来的 binary 不是 ABI 稳定的，而且必定打包了 Swift runtime。新的系统发现 app 包中有 Swift runtime 后，就会选择不去使用系统本身的 Swift runtime。这种情况下一切保持和现在不变。旧版本的 Xcode 只有旧版本的 iOS SDK，所以自然你也没有办法用到新系统的 Swift 写的框架，系统肯定不需要在同一个进程中跑两个 Swift runtime。</p>
<p>简单说，你还可以一直使用 Xcode 10.1 直到 Apple 不再接受它打包的 app。不过这样的话，你不能使用新版本 Swift 的任何特性，也不能从 ABI 稳定中获得任何好处。</p>
<h4 id="我升级了-Xcode-10-2，但是还想用-Swift-4-的兼容模式，会怎么样？"><a href="#我升级了-Xcode-10-2，但是还想用-Swift-4-的兼容模式，会怎么样？" class="headerlink" title="我升级了 Xcode 10.2，但是还想用 Swift 4 的兼容模式，会怎么样？"></a>我升级了 Xcode 10.2，但是还想用 Swift 4 的兼容模式，会怎么样？</h4><p>首先你需要弄清楚 Swift 的编译器版本和语言兼容版本的区别：</p>
<p>同一个 Xcode 版本默认使用的编译器版本只有一个 (在你不更换 toolchain 的前提下)，当我们在说到“使用 Xcode10.2 的 Swift 4 兼容模式”时，我们其实指的是，使用 Xcode 10.2 搭载的 Swift 5.0 版本的编译器，它提供了 4.2 的语法兼容，可以让我们不加修改地编译 Swift 4.2 的代码。即使你在 Xcode 10.2 中选择语言为 Swift 4，你所得到的二进制依然是 ABI 稳定的。ABI 和你的语言是 Swift 4 还是 Swift 5 无关，只和你的编译器版本，或者说 Xcode 版本有关。</p>
<blockquote>
<p>多提一句，即使你选择了 Swift 4 的语言兼容，只要编译器版本 (当然，以及对应的标准库版本) 是 5.0 以上，你依然可以使用 Swift 5 的语法特性 (比如新增加的类型等)。</p>
</blockquote>
<h4 id="看起来-ABI-稳定很美好，那么代价呢？"><a href="#看起来-ABI-稳定很美好，那么代价呢？" class="headerlink" title="看起来 ABI 稳定很美好，那么代价呢？"></a>看起来 ABI 稳定很美好，那么代价呢？</h4><p>Good question! 我们在第一个问题里就提到过，一切都会很美好，直到下一个版本。因为 Swift runtime 现在被放到 iOS 系统里了，所以想要升级就没那么容易了。</p>
<p>在 ABI 稳定之前，Swift runtime 是作为开发工具的一部分，被作为库打包到 app 中的。这样一来，在开发时，我们可以随意使用新版本 Swift 的类型或特性，因为它们的版本是开发者自己决定的。不过，当 ABI 稳定后，Swift runtime 变为了用户系统的一部分，它从开发工具，变为了运行的环境，不再由我们开发者唯一决定。比如说，对应 iOS 13 的 Swift 6 的标准库中添加了某个类型 A，但是在 iOS 12.2 这个只搭载了 Swift 5 的系统中，并没有这个类型。这意味着我们需要在使用 Swift 的时候考虑设备兼容的问题：如果你需要兼容那些搭载了旧版本 Swift 的系统，那你将无法在代码里使用新版本的 Swift runtime 特性。</p>
<p>这和我们一直以来适配新系统的 API 时候的情况差不多，在 Swift 5 以后，我们需要等到 deploy target 升级到对应的版本，才能开始使用对应的 Swift 特性。这意味着，我们可能会需要写一些这样的兼容代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 假如 Swift 6.0 是 iOS 13.0 的 Swift 版本</span><br><span class="line">if #available(iOS 13.0, *) &#123;</span><br><span class="line">    // Swift 6.0 标准库中存在 A</span><br><span class="line">    let a = A()</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 不存在 A 时的处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于“新添加的某个类型”这种程度的兼容，我们可以用上面的方式处理。但是对于更靠近语言层面的一些东西 (比如现在已有的 Codable 这样的特性)，恐怕适配起来就没有那么简单了。在未来，Deployment target 可能会和 Swift 语言版本挂钩，新的语言特性出现后，我们可能需要等待一段时间才能实际用上。而除了那些纯编译期间的内容外，任何与 Swift runtime 有关的特性，都会要遵守这个规则。</p>
<h4 id="可以像现在一样打包新版本的-Swift-runtime-到-app-里，然后指定用打包的-Swift-版本么"><a href="#可以像现在一样打包新版本的-Swift-runtime-到-app-里，然后指定用打包的-Swift-版本么" class="headerlink" title="可以像现在一样打包新版本的 Swift runtime 到 app 里，然后指定用打包的 Swift 版本么"></a>可以像现在一样打包新版本的 Swift runtime 到 app 里，然后指定用打包的 Swift 版本么</h4><p>不能，对于包含有 Swift runtime 的系统，如果运行的 binary 是 ABI 稳定的，那么就必须使用系统提供的 Swift。这里的主要原因是，Apple 想要保留使用 Swift 来实现系统框架的可能性：</p>
<ul>
<li>如果允许两个 Swift runtime (系统自带，以及 app 打包的)，那么这两个运行时将无法互相访问，app 也无法与系统的 Swift 框架或者第三方的 ABI 稳定的框架进行交互。</li>
<li>如果允许完全替换 Swift runtime，系统的 Swift 框架将执行用户提供的 Swift 标准库中的代码，这将造成重大的安全隐患。</li>
</ul>
<h4 id="有任何可能性让我能无视系统版本，去使用-Swift-的新特性么"><a href="#有任何可能性让我能无视系统版本，去使用-Swift-的新特性么" class="headerlink" title="有任何可能性让我能无视系统版本，去使用 Swift 的新特性么"></a>有任何可能性让我能无视系统版本，去使用 Swift 的新特性么</h4><p>有，但是相对麻烦，很大程度上也依赖 Apple 是否愿意支持。如果你还记得 iOS 5.0 引入 ARC 时，Apple 为了让 iOS 4.3 和之前的系统也能使用 ARC 的代码，在 deployment target 选到 iOS 4.3 或之前时，会用 static link 的方式打包一个叫做 libarclite 的库，其中包含了 ARC 所需要的一些 runtime 方法。对于 ABI 稳定后的 Swift，也许可以采用类似做法，来提供兼容。</p>
<blockquote>
<p>这种做法在感觉上和 Android 的 Support Library Packages 的方式类似，但是 Apple 似乎不是很倾向于提供这样的官方支持。所以之后要看有没有机会依靠社区力量来提供 Swift 的兼容支持了。</p>
</blockquote>
<p>不能第一时间用上新的语言特性，必然会打击大家进行适配和使用新特性的积极性，也势必会影响到语言的发展和快速迭代，可以说这一限制是相当不利的。</p>
<p>所以，对于一般的 app 开发者来说，ABI 稳定其实就是一场博弈：你现在有更小的 app 尺寸，但是却被限制了无法使用最新的语言特性，除非你提升 app 的 depolyment target。</p>
<h4 id="我是框架开发者，ABI-稳定后我可以用-binary-形式来发布了么？"><a href="#我是框架开发者，ABI-稳定后我可以用-binary-形式来发布了么？" class="headerlink" title="我是框架开发者，ABI 稳定后我可以用 binary 形式来发布了么？"></a>我是框架开发者，ABI 稳定后我可以用 binary 形式来发布了么？</h4><p>还不能。ABI 稳定是使用 binary 发布框架的必要非充分条件。框架的 binary 在不同的 runtime 是兼容了，但是作为框架，现在是依靠一个 .swiftmodule 的二进制文件来描述 API Interface 的，这个二进制文件中包含了序列化后的 AST (更准确说，是 interface 的 SIL)，以及编译这个 module 时的平台环境 (Swift 编译器版本等)。</p>
<p>ABI 稳定并不意味着编译工具链的稳定，对于框架来说，想要用 binary 的方式提供框架，除了 binary 本身稳定以外，还需要描述 binary 的方式 (也就是现在的 swiftmodule) 也稳定，而这正在开发中。将来，Swift 将为 module 提供文本形式的 .swiftinterface 作为框架 API 描述，然后让未来的编译器根据这个描述去“编译”出对应的 .swiftmodule 作为缓存并使用。</p>
<p>这一目标被称为 module stability，当达到 module stability 后，你就可以使用 binary 来发布框架了 (当然，这种 binary 框架只支持带有 ABI 稳定的 Swift runtime 的平台，也就是 iOS 12.2 及以上)。</p>
<h4 id="能总结一下-ABI-稳定，或者展望一下未来么？"><a href="#能总结一下-ABI-稳定，或者展望一下未来么？" class="headerlink" title="能总结一下 ABI 稳定，或者展望一下未来么？"></a>能总结一下 ABI 稳定，或者展望一下未来么？</h4><p>ABI 稳定最大的受益者应该是 Apple，这让 Apple 在自己的生态系统中，特别是系统框架中，可以使用 Swift 来进行实现。在我看来，Swift ABI 稳定为 Apple 开发平台的一场革命奠定了基础。在接下来的几年里，如果你还想要关注 Apple 平台，可能下面几件事情会特别重要：</p>
<ul>
<li>Apple 什么时候发布第一个 Swift 写的系统框架</li>
<li>Apple 什么时候开始提供第一个 Swift only 的 API</li>
<li>Apple 什么时候开始“锁定” Objective-C 的 SDK，不再为它增加新的 API</li>
<li>Apple 什么时候开始用 Swift 特性更新现有的 Objective-C SDK</li>
</ul>
<p>这些事情也许会在未来几年陆续发生。面对微软从 Win32 API 向 .Net 一路迁移，到今天的 UWP (Universal Windows Platform)，Google 来势汹汹的 Fuchsia 和 Dart，Swift 是 Apple 唯一能与它们抗衡的答案。相比于微软提供的泛型和并行编程模型，Google 的 Flutter 的跨平台的先天优势，Apple 平台基于 Objective-C 的 API 的易用性已然被抛开很远。虽然 Apple 在 2014 年承诺过依然维护 Objective-C，但是经过 Swift 这五年的发展，随着 Swift ABI 的稳定，什么时候如果 Objective-C 成为了继续发展的阻碍，相信 Apple 已经有足够的理由将它抛弃。</p>
<p>作为 Apple 平台的从业者，我们也许正处在另一个时代变革的开端。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/21/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小怪兽">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/girl.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BUG吧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/21/hello-world/" itemprop="url">iOS App 后台任务的坑</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-21T14:09:29+07:00">
                2019-05-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>大多数 iOS App 在进入后台之后都会将一些关键任务封装到 Background Task 里，否则程序在若干秒之后就会被系统 Suspend。启动 Background Task 之后，可以获得 3 分钟继续执行代码的时间。</p>
<p>最近在调查 Messenger 的 Background Crash 问题，最后都追踪到和 Background Task 相关，和大家分享下一些要点。</p>
<h3 id="Crash-信号"><a href="#Crash-信号" class="headerlink" title="Crash 信号"></a>Crash 信号</h3><p>一般 App 都有自己的 crash 日志采集工具，这类工具一般有三个问题。第一是在工具启动之前的 crash 日志无法捕捉，第二是如果 App 启动闪退日志无法上传，第三是一些特殊场景的系统强杀无法捕捉 crash 信号。</p>
<p>解决第一个问题，只要将工具的执行时间尽可能提前，或者确保之前的代码及可能简单可靠。</p>
<p>解决第二个问题，可以采用我之前分享过的，使用 NSURLSession 的 background mode。</p>
<p>解决第三个问题，需要依赖于 Apple 自己的 crash 信号，这也是很多开发团队所忽视的一点。</p>
<p>Apple 也有自己的 crash 日志采集，不过基于用户隐私的考虑，这个 crash 日志并不可靠，主要存在以下几方面的缺陷：</p>
<ul>
<li>用户需同意上传并分享数据，据闻，同意比例不足 20%，所以无法准确确定某个 crash 的实际影响面。</li>
<li>crash 日志工具简陋，通过 Xcode -&gt; Organizer 打开，选中 App 就能从 Apple 后台下载某个版本的 crash 日志，无法通过某个条件做筛选，比如你不能过滤出所有 SIGKILL 的日志。</li>
<li>日志不全，Apple 按照自己的规则呈现 crash 样本，一个 App 实际线上的 crash 非常之多，但 Apple 列出的 crash 样本只有数十个，规则不明。</li>
<li>crash 日志只保存一周，一周刷新一次，所有比较明智的做法是写个脚本同步下来，上传到自己的后台。</li>
</ul>
<h3 id="Background-Task-花式-crash"><a href="#Background-Task-花式-crash" class="headerlink" title="Background Task 花式 crash"></a>Background Task 花式 crash</h3><p>Background Task 的 API 及其简单，begin 和 end 之间的代码全部进入 Background Task 的范畴。但简单的代码隐藏着不小的风险，下面列出三个比较容易出现的 crash。而且这三个 crash 都是客户端自带的 crash 采集工具无法捕捉的，只能通过 Apple 的 crash 日志获得信号。原因很简单，这些 crash 发生的时候 app 一般处于 suspend 状态，根本没有机会执行任何代码，系统直接发送 SIGKILL 信号后就将 app 强杀，并生成一个系统日志，一个只能 Apple 访问的日志，还得用户先同意上传分享。</p>
<h3 id="0xdead10cc"><a href="#0xdead10cc" class="headerlink" title="0xdead10cc"></a>0xdead10cc</h3><p>这个 crash 日志一般长这样：</p>
<blockquote>
<p>Exception Type: EXC_CRASH (SIGKILL) Exception Codes: 0x0000000000000000, 0x0000000000000000 Exception Note: EXC_CORPSE_NOTIFY Termination Reason: Namespace SPRINGBOARD, Code 0xdead10cc<br>Termination Description: SPRINGBOARD, com.xxx.xxx was task-suspended with locked system file</p>
</blockquote>
<p>原因我之前介绍过，当你的 App 有 Extension，而且 Extension 存在和 Host App 共享数据的需求，一般做法会将 db 文件放入 shared container 目录下，此时你的 App 就有大概率会发生这种 crash。</p>
<p>App 进入后台运行 Background Task，end 之后 App 被系统 suspend，如果 suspend 之后还存在任何访问 db 的操作，此时 App 会立马被系统强杀，这是 Apple 出于保护数据库文件的完整的考虑。</p>
<p>所以正确的做法是将所有有可能在 App 进入后台之后，还会发生的 db 操作统统封入 Background Task，以确保安全。这个代码写在 db layer 可能更加合适。</p>
<p>而且 Apple 推荐当你想启动 Background Task 的时候，其实并不需要考虑当前 App 是出于 foreground 还是 background，即使 App 在前台启动 Background Task，也并不会占用进入后台之后 3 分钟额度，所以放心大胆的把关键代码放进 Background Task 吧。</p>
<h3 id="0xbada5e47"><a href="#0xbada5e47" class="headerlink" title="0xbada5e47"></a>0xbada5e47</h3><p>当你听从了上面的建议，大大方方的把尽可能多的关键代码封入 Background Task 后，那么你可能会遇到下面的 crash：</p>
<blockquote>
<p>Exception Type: EXC_CRASH (SIGKILL) Exception Codes: 0x0000000000000000, 0x0000000000000000 Exception Note: EXC_CORPSE_NOTIFY Termination Reason: Namespace ASSERTIOND, Code 0xbada5e47</p>
</blockquote>
<p>同理也是和 Background Task 相关，原因是 Apple 认为你启动了过多的 Background Task，所以要杀掉。多少算多呢？几十个不多，当前的 threshold 是 1000 个，超过 1000 个才会强杀。如果你的 Background Task 封装发生在 db layer，出现大量数据过来需要存储或读取的时候，还是有可能会 hit 这个 limit。</p>
<p>另一个 0xbada5e47 的可能原因是，Background Task 在超时之后会调用 expiry handler，无论你有多少个 Background Task，所有 expiry handler 执行的时间不能超过若干秒，一旦超过也会被枪杀。所以在 expiry handler 里面切忌有任何比如 disk io 的耗时操作。</p>
<h3 id="0x8badf00d"><a href="#0x8badf00d" class="headerlink" title="0x8badf00d"></a>0x8badf00d</h3><p>说到 0x8badf00d，大家都很熟悉了，当你的主线程卡住的时间太长，系统的 Watchdog 会将你的 App 强杀，并生成一个带有 0x8badf00d 的 crash 日志。</p>
<p>Background Task 其实也可以 0x8badf00d 的，比如：</p>
<blockquote>
<p>Exception Type: EXC_CRASH (SIGKILL) Exception Codes: 0x0000000000000000, 0x0000000000000000 Exception Note: EXC_CORPSE_NOTIFY Termination Reason: Namespace SPRINGBOARD, Code 0x8badf00d</p>
</blockquote>
<p>当你的代码逻辑会产生 leaked Background Task 时，就会出现上面的系统强杀 crash 日志了，什么是 leaked Background Task 呢？看代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)startBgTask</span><br><span class="line">&#123;</span><br><span class="line">  self.bgTaskID = [[UIApplication sharedApplication] beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">    NSLog(@&quot;Expired: %lu&quot;, (unsigned long)self.bgTaskID);</span><br><span class="line">    [[UIApplication sharedApplication] endBackgroundTask:self.bgTaskID];</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)endBgTask</span><br><span class="line">&#123;</span><br><span class="line">  [[UIApplication sharedApplication] endBackgroundTask:self.bgTaskID];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码如果 startBgTask 执行两次，就一定会出现 leaked Background Task，因为 self.bgTaskID 第二次会被赋予一个新的 ID，之前的 task ID 就丢失了，无法正确调用 end。</p>
<p>那怎么判断 0x8badf00d 到底是主线程卡死，还是出现了 leaked Background Task ？很简单，看主线程的 stack，如果长这样：</p>
<blockquote>
<p>Thread 0 Crashed: 0 libsystem_kernel.dylib 0x000000018472be08 0x18472b000 + 3592 1 libsystem_kernel.dylib 0x000000018472bc80 0x18472b000 + 3200 2 CoreFoundation 0x0000000184c6ee40 0x184b81000 + 974400 3 CoreFoundation 0x0000000184c6c908 0x184b81000 + 964872 4 CoreFoundation 0x0000000184b8cda8 0x184b81000 + 48552 5 GraphicsServices 0x0000000186b6f020 0x186b64000 + 45088 6 UIKit 0x000000018eb6d78c 0x18e850000 + 3266444 7 Messenger 0x0000000103015ee4 0x102ff8000 + 122596 8 libdyld.dylib 0x000000018461dfc0 0x18461d000 + 4032</p>
</blockquote>
<p>这个 stack 很经典，经常会看到，不需要 symbolicate 也能知道是干啥，这是 UI 线程 runloop 处于 idle 状态的 stack，在等待 kernel 的 message。表示 UI 线程此时处于闲置状态，这种状态下的系统强杀大概率是由于 leaked Background Task 导致的。</p>
<h3 id="善用设备本地的-crash-日志"><a href="#善用设备本地的-crash-日志" class="headerlink" title="善用设备本地的 crash 日志"></a>善用设备本地的 crash 日志</h3><p>当用户的手机遇到 crash，而你既无法重现又在后台找不到 crash 日志的时候，此时你最大的希望就是手机本地的 crash 日志了。</p>
<p>本地日志位于 Settings -&gt; Privacy -&gt; Analytics -&gt; Analytics Data。打开看下，说不定你所开发的 App 的 crash 日志，我手机上微信和支付宝都有好些日志。</p>
<p>日志排序先是按照 App 的名称，再按日志发生的日期。</p>
<p>如果调查内存使用过多的 crash，可以查看 JetsamEvent-xxx 开头的日志。</p>
<p>如果想知道 App 发生 crash 前系统有哪些异常日志，需要首先在设备上安装一个 loggingiOS.mobileconfig 的文件，这个文件基本上就是让用户授权给你记录系统行为，用户在遇到 crash 的时候，同时按下两个音量键 + 电源键，松手震动之后，系统会将过去一段时间的关键日志记录下来，对于分析一些疑难杂症很有帮助，这种日志一般为 sysdiagnose_xxx 开头。</p>
<p>安装上述 loggingiOS.mobileconfig 文件之后，还有另外一个好处，Apple 会记录更多而且更详细的 crash 日志了，因为用户授权过，所以 Apple 可以大胆施为了。这类日志的文件名一般为：stacks + appName - date.ips。</p>
<p>如果用户的设备能重现你所调查的问题，还有另一个简单高效的办法，将手机 usb 连接 mac，然后启动 mac 上的 Console App，就能直观的看到所有系统关键日志了，比如网络异常日志可以查看 nsurlsessiond，定位异常日志查看 locationd，Background Task 异常日志可以查看 assertiond，也可以直接按照你 app 的进程名进行过滤，查看生命周期以及被强杀的原因。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上是最近调查 Background Task crash 的一些知识点分享，希望对大家有所帮助。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/uploads/girl.jpg" alt="小怪兽">
          <p class="site-author-name" itemprop="name">小怪兽</p>
           
              <p class="site-description motion-element" itemprop="description">世界更新的速度比你努力的速度要快，努力的目的是不至于被世界落下太远。</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">小怪兽</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
